# 端口冲突故障手册

## 故障特征
**错误关键词**: `Address already in use`、`EADDRINUSE`、`bind failed`

**典型表现**:
- 服务启动失败
- 日志显示无法绑定端口
- 新版本部署失败

## 问题原理
TCP/UDP 端口是**物理机级别**的系统资源，同一端口同一时间只能被一个进程监听。
当新进程尝试绑定已被占用的端口时，系统返回 EADDRINUSE 错误。

**特殊情况**: 
- TIME_WAIT 状态：连接关闭后端口可能保持 2MSL（通常 60s）
- SO_REUSEADDR：允许重用 TIME_WAIT 状态的端口

## ⚠️ K8s 端口概念澄清（重要）
**端口冲突只发生在物理机层面，不要混淆以下概念：**

| 端口类型 | 说明 | 是否会冲突 |
|---------|------|-----------|
| **物理机端口** | 主机上进程实际监听的端口 | ✅ 会冲突 |
| hostPort | Pod 直接暴露到主机的端口 | ✅ 会冲突（同一节点） |
| NodePort | Service 暴露到节点的端口（30000-32767） | ✅ 会冲突（同一 NodePort 值） |
| containerPort | 容器内部监听的端口 | ❌ **不会冲突**（Pod 网络隔离） |
| Service port | Service 的虚拟端口 | ❌ **不会冲突**（ClusterIP 不同） |

**常见误判**：
- ❌ 多个 Deployment 的 containerPort 都是 8080 → 这**不是**冲突
- ❌ 多个 Service 的 targetPort 都是 8080 → 这**不是**冲突
- ✅ 两个进程都 bind 到主机的 0.0.0.0:8080 → 这**是**冲突
- ✅ 两个 Pod 都用 hostPort: 8080 调度到同一节点 → 这**是**冲突

## 常见场景与根因

### 场景 1: 旧版本进程未停止（最常见，占 70%）
**特征**: 同名进程已在运行
**根因**:
- 部署时未正确停止旧进程
- 热更新失败，旧进程残留
- systemd 服务停止不彻底
**修复**: 终止旧进程后重新启动

### 场景 2: 多实例端口冲突（占 15%）
**特征**: 同一机器部署多个实例，端口相同
**根因**:
- 未为不同实例配置不同端口
- K8s hostPort 冲突
**修复**: 为不同实例分配不同端口

### 场景 3: 不同服务端口冲突（占 10%）
**特征**: 占用端口的是其他服务
**根因**:
- 多个服务默认使用相同端口（如 8080）
- 新部署服务与现有服务端口重复
**修复**: 修改其中一个服务的端口

### 场景 4: 僵尸进程占用（占 5%）
**特征**: 进程已不存在但端口仍被占用
**根因**: 
- 进程异常退出，内核未及时释放端口
- TIME_WAIT 状态
**修复**: 等待自动释放或重启网络服务

## 诊断方法论

### 通用诊断流程
1. 从错误日志提取端口号
2. `ss -tlnp | grep <port>` 或 `lsof -i:<port>` 定位占用进程
3. 判断占用进程类型（旧版本/其他服务/僵尸）
4. 针对性处理

### 关键诊断命令
```bash
# 查看端口占用
ss -tlnp | grep <port>
# 或
netstat -tlnp | grep <port>

# 获取详细进程信息
lsof -i:<port>

# 查看进程详情
ps -fp <PID>
```

## 修复策略

### 终止旧进程（推荐）
```bash
# 优雅终止
kill -15 <PID>

# 等待 5 秒后检查
sleep 5 && ps -p <PID>

# 如仍存在，强制终止
kill -9 <PID>
```

### 更换端口（如果无法终止占用进程）
修改应用配置，使用其他端口

### K8s 环境特殊处理
- 避免使用 hostPort
- 使用 Service 而非直接暴露端口
- 检查 NodePort 是否冲突

## 预防措施
- 部署脚本中先检查端口是否被占用
- 使用进程管理器（systemd）确保服务正确停止
- 配置 preStop hook 实现优雅关闭
- 不同环境使用不同端口段
- 避免使用常见默认端口（8080、3000 等）
